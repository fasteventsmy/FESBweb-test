---
const { data = [] } = Astro.props as { data: Array<{ state: string; count: number }> };
---
<style>
  .coverage{ display:grid; gap:1rem; grid-template-columns: 1fr; }
  @media (min-width: 900px){ .coverage{ grid-template-columns: 1.2fr .8fr; align-items:center; } }

  .map{
    aspect-ratio: 16/9; width: 100%;
    background: radial-gradient(1200px 600px at 40% 40%, rgba(127,102,255,.18), transparent 60%), linear-gradient(180deg, rgba(255,255,255,.04), rgba(255,255,255,.02));
    border:1px solid rgba(255,255,255,.06); border-radius:16px; position: relative; overflow:hidden;
  }
  .silhouette{ position:absolute; inset:0; display:grid; place-items:center; opacity:.7; }
  .legend{ display:grid; grid-template-columns: repeat(auto-fit, minmax(220px,1fr)); gap:.75rem; }
  .pill{ display:flex; justify-content:space-between; align-items:center; background: var(--card); border:1px solid rgba(255,255,255,.06); border-radius: 12px; padding:.6rem .75rem; }
  .count{ font-weight:800; font-size:1.1rem; color:#d8d2ff; }
</style>

<div class="coverage" id="coverage-root">
  <div class="map">
    <div class="silhouette">
      <svg width="84%" viewBox="0 0 800 320" fill="none" xmlns="http://www.w3.org/2000/svg" style="max-width:900px">
        <path d="M40 210 C 120 160, 210 140, 280 180 C 350 220, 430 210, 520 170 C 580 145, 650 120, 760 138 L 760 200 C 640 210, 560 240, 470 260 C 360 285, 280 260, 210 230 C 150 205, 90 210, 40 210 Z" fill="rgba(127,102,255,.35)" stroke="rgba(255,255,255,.35)"/>
        <circle cx="640" cy="110" r="40" fill="rgba(127,102,255,.35)" stroke="rgba(255,255,255,.35)"/>
      </svg>
    </div>
  </div>
  <div class="legend">
    {data.map(d => (
      <div class="pill">
        <span>{d.state}</span>
        <span class="count" data-target={d.count}>0</span>
      </div>
    ))}
  </div>
</div>

<script>
  const root = document.getElementById('coverage-root');
  if (root) {
    const io = new IntersectionObserver((entries) => {
      if (!entries.some(e => e.isIntersecting)) return;
      root.querySelectorAll(".count").forEach(el => {
        const target = Number(el.getAttribute("data-target") || 0);
        const dur = 900; const t0 = performance.now();
        const tick = (now) => {
          const p = Math.min(1, (now - t0)/dur);
          el.textContent = Math.round(target * p).toString();
          if (p < 1) requestAnimationFrame(tick);
        };
        requestAnimationFrame(tick);
      });
      io.disconnect();
    }, { threshold: .2 });
    io.observe(root);
  }
</script>
